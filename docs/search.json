[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "This repository has teaching materials for a hands-on Introduction to single-cell RNA-seq workshop. This workshop will instruct participants on how to design a single-cell RNA-seq experiment, and how to efficiently manage and analyze the data starting from count matrices. This will be a hands-on workshop in which we will focus on using the Scanpy package using Python/Jupyter Lab.\n\n\n\n\n\n\nNote\n\n\n\nThese materials were developed for a trainer-led workshop, but are amenable to self-guided learning."
  },
  {
    "objectID": "index.html#applications",
    "href": "index.html#applications",
    "title": "Introduction to single-cell RNA-seq",
    "section": "Applications",
    "text": "Applications\nAnaconda"
  },
  {
    "objectID": "index.html#packages",
    "href": "index.html#packages",
    "title": "Introduction to single-cell RNA-seq",
    "section": "Packages",
    "text": "Packages\n\nconda create -n scrna_py python==3.12\nconda activate scrna_py\nconda install jupyter pandas matplotlib \nconda install -c conda-forge scanpy python-igraph leidenalg"
  },
  {
    "objectID": "lessons/05_theory_of_PCA.html",
    "href": "lessons/05_theory_of_PCA.html",
    "title": "Theory of PCA",
    "section": "",
    "text": "Approximate time: 90 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "Theory of PCA"
    ]
  },
  {
    "objectID": "lessons/05_theory_of_PCA.html#learning-objectives",
    "href": "lessons/05_theory_of_PCA.html#learning-objectives",
    "title": "Theory of PCA",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain how similarity between cells/samples can be evaluated by the Principal Components Analysis (PCA)",
    "crumbs": [
      "Day 1 Self-learning:",
      "Theory of PCA"
    ]
  },
  {
    "objectID": "lessons/05_theory_of_PCA.html#principal-component-analysis-pca",
    "href": "lessons/05_theory_of_PCA.html#principal-component-analysis-pca",
    "title": "Theory of PCA",
    "section": "Principal Component Analysis (PCA)",
    "text": "Principal Component Analysis (PCA)\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation as well as similarity, and to bring out strong patterns in a dataset; it is one of the methods used for “dimensionality reduction”. We will briefly go over PCA in this lesson (adapted from StatQuests/Josh Starmer’s YouTube video), but we strongly encourage you to explore the video StatQuest’s video for a more thorough explanation/understanding.\n\nBasic explanation with a simple example\nLet’s say you had quantified the expression of four genes in two samples (or cells), you could plot the expression values of those genes with one sample represented on the x-axis and the other sample on the y-axis as shown below:\n\n\n\nYou could draw a line through the data in the direction representing the most variation, which is on the diagonal in this example. The maximum variation in the dataset is between the genes that make up the two endpoints of this line.\nWe also see the genes vary somewhat above and below the line. We could draw another line through the data representing the second most amount of variation in the data, since this plot is in 2D (2 axes).\n\n\n\nThe genes near the ends of each line would be those with the highest variation; these genes have the greatest influence on the direction of the line, mathematically.\n\n\n\nFor example, a small change in the value of Gene C would greatly change the direction of the longer line, whereas a small change in Gene A or Gene D would have little affect on it.\n\n\n\nWe could also rotate the entire plot and view the lines representing the variation as left-to-right and up-and-down. We see most of the variation in the data is left-to-right (longer line) and the second most variation in the data is up-and-down (shorter line). You can now think of these lines as the axes that represent the variation. These axes are essentially the “Principal Components”, with PC1 representing the most variation in the data and PC2 representing the second most variation in the data.\n\n\n\nNow, what if we had three samples/cells, then we would have an extra direction in which we could have variation (3D). Therefore, if we have N samples/cells we would have N-directions of variation or N principal components (PCs)! Once these PCs have been calculated, the PC that deals with the largest variation in the dataset is designated PC1, and the next one is designated PC2 and so on.\nOnce the PCs have been determined for an dataset, we have to figure out how each sample/cell fits back into that context to enable us to visualize the similarities/dissimilarities in an intuitive manner. The question here is “what is sample_X’s score for a given PC based on the gene expression in sample_X?”. This is the actual step where the dimensionality is reduced, since you plot PC scores for each sample/cell on the final PCA plot.\nPC scores are calculated for all sample-PC pairs as described in the steps and schematic below:\n\nFirst, each gene is assigned an “influence” score based on how much it influenced each PC. Genes that did not have any influence on a given PC get scores near zero, while genes with more influence receive larger scores. Genes on the ends of a PC line will have a larger influence, so they would receive larger scores but with opposite signs.\n\n\n\n\n\nOnce the influence has been determined, the score for each sample is calculated using the following equation:\nSample1 PC1 score = (read count * influence) + … for all genes\n\nFor our 2-sample example, the following is how the scores would be calculated:\n## Sample1\nPC1 score = (4 * -2) + (1 * -10) + (8 * 8) + (5 * 1) = 51\nPC2 score = (4 * 0.5) + (1 * 1) + (8 * -5) + (5 * 6) = -7\n\n## Sample2\nPC1 score = (5 * -2) + (4 * -10) + (8 * 8) + (7 * 1) = 21\nPC2 score = (5 * 0.5) + (4 * 1) + (8 * -5) + (7 * 6) = 8.5\nHere is a schematic that goes over the first 2 steps:\n\n\n\n\nOnce these scores are calculated for all the PCs, they can be plotted on a simple scatter plot. Below is the plot for the example here, going from the 2D matrix to a 2D plot:",
    "crumbs": [
      "Day 1 Self-learning:",
      "Theory of PCA"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html",
    "href": "lessons/03_SC_quality_control-setup.html",
    "title": "Quality Control Setup",
    "section": "",
    "text": "Approximate time: 90 minutes",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#raw-data",
    "href": "lessons/03_SC_quality_control-setup.html#raw-data",
    "title": "Quality Control Setup",
    "section": "Raw data",
    "text": "Raw data\nThis dataset is available on GEO (GSE96583), however the available counts matrix lacked mitochondrial reads, so we downloaded the BAM files from the SRA (SRP102802). These BAM files were converted back to FASTQ files, then run through Cell Ranger to obtain the count data that we will be using.\n\n\n\n\n\n\nNote\n\n\n\nThe count data for this dataset is also freely available from 10X Genomics and is used in the Seurat tutorial.",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#metadata",
    "href": "lessons/03_SC_quality_control-setup.html#metadata",
    "title": "Quality Control Setup",
    "section": "Metadata",
    "text": "Metadata\nIn addition to the raw data, we also need to collect information about the data; this is known as metadata. There is often a temptation to just start exploring the data, but it is not very meaningful if we know nothing about the samples that this data originated from.\nSome relevant metadata for our dataset is provided below:\n\nThe libraries were prepared using 10X Genomics version 2 chemistry\nThe samples were sequenced on the Illumina NextSeq 500\nPBMC samples from eight individual lupus patients were separated into two aliquots each.\n\nOne aliquot of PBMCs was activated by 100 U/mL of recombinant IFN-β for 6 hours.\nThe second aliquot was left untreated.\nAfter 6 hours, the eight samples for each condition were pooled together in two final pools (stimulated cells and control cells). We will be working with these two, pooled samples. (We did not demultiplex the samples because SNP genotype information was used to demultiplex in the paper and the barcodes/sample IDs were not readily available for this data. Generally, you would demultiplex and perform QC on each individual sample rather than pooling the samples.)\n\n12,138 and 12,167 cells were identified (after removing doublets) for control and stimulated pooled samples, respectively.\nSince the samples are PBMCs, we will expect immune cells, such as:\n\nB cells\nT cells\nNK cells\nmonocytes\nmacrophages\npossibly megakaryocytes\n\n\nIt is recommended that you have some expectation regarding the cell types you expect to see in a dataset prior to performing the QC. This will inform you if you have any cell types with low complexity (lots of transcripts from a few genes) or cells with higher levels of mitochondrial expression. This will enable us to account for these biological factors during the analysis workflow.\nNone of the above cell types are expected to be low complexity or anticipated to have high mitochondrial content.",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#todo-download-instructions",
    "href": "lessons/03_SC_quality_control-setup.html#todo-download-instructions",
    "title": "Quality Control Setup",
    "section": "TODO: download instructions",
    "text": "TODO: download instructions",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#project-organization",
    "href": "lessons/03_SC_quality_control-setup.html#project-organization",
    "title": "Quality Control Setup",
    "section": "Project organization",
    "text": "Project organization\nOne of the most important parts of research that involves large amounts of data, is how best to manage it. We tend to prioritize the analysis, but there are many other important aspects of data management that are often overlooked in the excitement to get a first look at new data. The HMS Data Management Working Group, discusses in-depth some things to consider beyond the data creation and analysis.\nOne important aspect of data management is organization. For each experiment you work on and analyze data for, it is considered best practice to get organized by creating a planned storage space (directory structure). We will do that for our single-cell analysis.\nLook inside your project space and you will find that a directory structure has been setup for you:\n\nsingle_cell_rnaseq/\n├── data\n├── results\n└── figures",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#new-script",
    "href": "lessons/03_SC_quality_control-setup.html#new-script",
    "title": "Quality Control Setup",
    "section": "New script",
    "text": "New script\nNext, open a new Jupyter Notebook file (ipynb), and start with some comments to indicate what this file is going to contain:\n\n# July/August 2021\n# HBC single-cell RNA-seq workshop\n\n# Single-cell RNA-seq analysis - QC\n\nSave the Rscript as quality_control.ipynb. Your working directory should look something like this:\nTODO \n\nLoading libraries\nNow, we can load the necessary libraries:\n\nimport scanpy as sc\n\nimport warnings\nwarnings.simplefilter(action='ignore', \n                      category=FutureWarning)",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#loading-single-cell-rna-seq-count-data",
    "href": "lessons/03_SC_quality_control-setup.html#loading-single-cell-rna-seq-count-data",
    "title": "Quality Control Setup",
    "section": "Loading single-cell RNA-seq count data",
    "text": "Loading single-cell RNA-seq count data\nRegardless of the technology or pipeline used to process your raw single-cell RNA-seq sequence data, the output with quantified expression will generally be the same. That is, for each individual sample you will have the following three files:\n\nA file with the cell IDs, representing all cells quantified\nA file with the gene IDs, representing all genes quantified\nA matrix of counts per gene for every cell\n\nWe can explore these files by clicking the data/ctrl_raw_feature_bc_matrix folder:\n\n1. barcodes.tsv\nThis is a text file which contains all cellular barcodes present for that sample. Barcodes are listed in the order of data presented in the matrix file (i.e. these are the column names).\n\n\n\n2. features.tsv\nThis is a text file which contains the identifiers of the quantified genes. The source of the identifier can vary depending on what reference (i.e. Ensembl, NCBI, UCSC) you use in the quantification methods, but most often these are official gene symbols. The order of these genes corresponds to the order of the rows in the matrix file (i.e. these are the row names).\n\n\n\n3. matrix.mtx\nThis is a text file which contains a matrix of count values. The rows are associated with the gene IDs above and columns correspond to the cellular barcodes. Note that there are many zero values in this matrix.\n\nLoading this data into R requires us to use functions that allow us to efficiently combine these three files into a single count matrix. However, instead of creating a regular matrix data structure, the functions we will use create a sparse matrix to reduce the amount of memory (RAM), processing capacity (CPU) and storage required to work with our huge count matrix.\nScanpy allows us to easily read in the data by using the read_10x_mtx() function.",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#cell-metadata",
    "href": "lessons/03_SC_quality_control-setup.html#cell-metadata",
    "title": "Quality Control Setup",
    "section": "Cell metadata",
    "text": "Cell metadata\nTo being, we will not have much metadata in our scanpy object beyond the cell barcodes themselves. When we ran the filter_cells() function, it automatically calculated the number of genes with non-zero expression for each cell and stored it in a column titled n_genes:\n\nad.obs.head()\n\n\n\n\n\n\n\n\nn_genes\n\n\n\n\nAAACATACAATGCC-1\n874\n\n\nAAACATACATTTCC-1\n896\n\n\nAAACATACCAGAAA-1\n725\n\n\nAAACATACCAGCTA-1\n979\n\n\nAAACATACCATGCA-1\n362\n\n\n\n\n\n\n\nWe can ourselves add additional metadata in the .obs with relevant information (sample, sex, age, timepoint, etc). In our case, we can update the sample information to keep track that these cells came from our ctrl sample.\n\nad.obs[\"sample\"] = \"ctrl\"\nad.obs.head()\n\n\n\n\n\n\n\n\nn_genes\nsample\n\n\n\n\nAAACATACAATGCC-1\n874\nctrl\n\n\nAAACATACATTTCC-1\n896\nctrl\n\n\nAAACATACCAGAAA-1\n725\nctrl\n\n\nAAACATACCAGCTA-1\n979\nctrl\n\n\nAAACATACCATGCA-1\n362\nctrl",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#gene-metadata",
    "href": "lessons/03_SC_quality_control-setup.html#gene-metadata",
    "title": "Quality Control Setup",
    "section": "Gene metadata",
    "text": "Gene metadata\n\nad.var.head()\n\n\n\n\n\n\n\n\ngene_ids\nfeature_types\n\n\n\n\nMIR1302-2HG\nENSG00000243485\nGene Expression\n\n\nFAM138A\nENSG00000237613\nGene Expression\n\n\nOR4F5\nENSG00000186092\nGene Expression\n\n\nAL627309.1\nENSG00000238009\nGene Expression\n\n\nAL627309.3\nENSG00000239945\nGene Expression",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#counts-matrix",
    "href": "lessons/03_SC_quality_control-setup.html#counts-matrix",
    "title": "Quality Control Setup",
    "section": "Counts matrix",
    "text": "Counts matrix\nBy default, the counts matrix will be stored in a format known as a “sparse matrix” which is a way store large matrix data in an efficient way.\n\nad.X\n\n&lt;15688x33538 sparse matrix of type '&lt;class 'numpy.float32'&gt;'\n    with 9243628 stored elements in Compressed Sparse Column format&gt;\n\n\nTo access each value in the first 5 columns and rows, we can use the todense() function to get a preview of what is going on:\n\nad.X[1:5, 1:5].todense()\n\nmatrix([[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]], dtype=float32)\n\n\nThe values are primarily 0’s which is line with our expenctation of this zero-inflated data.",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#layers",
    "href": "lessons/03_SC_quality_control-setup.html#layers",
    "title": "Quality Control Setup",
    "section": "Layers",
    "text": "Layers\nThe .X is considered to be the default layer for calculations. Since we will later normalize our data, we want to ensure that we store our raw counts in a place we can access it later by making use of Layers where we can store multiple different count matrices and access them at will. So to start, we are going to stash away this matrix.\nWe will also specify the copy() function to ensure that the data is copied over, and that it doesn’t just point to .X (which may change in the future).\n\nad.layers[\"raw\"] = ad.X.copy()\nad\n\nAnnData object with n_obs × n_vars = 15756 × 33538\n    obs: 'n_genes', 'sample'\n    var: 'gene_ids', 'feature_types'\n    layers: 'raw'",
    "crumbs": [
      "Day 1:",
      "Quality Control Setup"
    ]
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html",
    "href": "lessons/02_SC_generation_of_count_matrix.html",
    "title": "Generation of count matrix",
    "section": "",
    "text": "Depending on the library preparation method used, the RNA sequences (also referred to as reads or tags), will be derived either from the 3’ ends (or 5’ ends) of the transcripts (10X Genomics, CEL-seq2, Drop-seq, inDrops) or from full-length transcripts (Smart-seq).\n\nImage credit: Papalexi E and Satija R. Single-cell RNA sequencing to explore immune cell heterogeneity, Nature Reviews Immunology 2018 (https://doi.org/10.1038/nri.2017.76)\nThe choice of method involves the biological question of interest. The following advantages are listed below for the methods:\n\n3’ (or 5’)-end sequencing:\n\nMore accurate quantification through the use of unique molecular identifiers distinguishing biological duplicates from amplification (PCR) duplicates\nLarger number of cells sequenced allows better identity of cell type populations\nCheaper per cell cost\nBest results with &gt; 10,000 cells\n\nFull length sequencing:\n\nDetection of isoform-level differences in expression\nIdentification of allele-specific differences in expression\nDeeper sequencing of a smaller number of cells\nBest for samples with low number of cells\n\n\nMany of the same analysis steps need to occur for 3’-end sequencing as for full-length, but 3’ protocols have been increasing in popularity and consist of a few more steps in the analysis. Therefore, our materials are going to detail the analysis of data from these 3’ protocols with a focus on the droplet-based methods (inDrops, Drop-seq, 10X Genomics).",
    "crumbs": [
      "Pre-reading:",
      "Generation of count matrix"
    ]
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-data---raw-data-to-count-matrix",
    "href": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-data---raw-data-to-count-matrix",
    "title": "Generation of count matrix",
    "section": "",
    "text": "Depending on the library preparation method used, the RNA sequences (also referred to as reads or tags), will be derived either from the 3’ ends (or 5’ ends) of the transcripts (10X Genomics, CEL-seq2, Drop-seq, inDrops) or from full-length transcripts (Smart-seq).\n\nImage credit: Papalexi E and Satija R. Single-cell RNA sequencing to explore immune cell heterogeneity, Nature Reviews Immunology 2018 (https://doi.org/10.1038/nri.2017.76)\nThe choice of method involves the biological question of interest. The following advantages are listed below for the methods:\n\n3’ (or 5’)-end sequencing:\n\nMore accurate quantification through the use of unique molecular identifiers distinguishing biological duplicates from amplification (PCR) duplicates\nLarger number of cells sequenced allows better identity of cell type populations\nCheaper per cell cost\nBest results with &gt; 10,000 cells\n\nFull length sequencing:\n\nDetection of isoform-level differences in expression\nIdentification of allele-specific differences in expression\nDeeper sequencing of a smaller number of cells\nBest for samples with low number of cells\n\n\nMany of the same analysis steps need to occur for 3’-end sequencing as for full-length, but 3’ protocols have been increasing in popularity and consist of a few more steps in the analysis. Therefore, our materials are going to detail the analysis of data from these 3’ protocols with a focus on the droplet-based methods (inDrops, Drop-seq, 10X Genomics).",
    "crumbs": [
      "Pre-reading:",
      "Generation of count matrix"
    ]
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#end-reads-includes-all-droplet-based-methods",
    "href": "lessons/02_SC_generation_of_count_matrix.html#end-reads-includes-all-droplet-based-methods",
    "title": "Generation of count matrix",
    "section": "3’-end reads (includes all droplet-based methods)",
    "text": "3’-end reads (includes all droplet-based methods)\nFor the analysis of scRNA-seq data, it is helpful to understand what information is present in each of the reads and how we use it moving forward through the analysis.\nFor the 3’-end sequencing methods, reads originating from different molecules of the same transcript would have originated only from the 3’ end of the transcripts, so would have a high likelihood of having the same sequence. However, the PCR step during library preparation could also generate read duplicates. To determine whether a read is a biological or technical duplicate, these methods use unique molecular identifiers, or UMIs.\n\nReads with different UMIs mapping to the same transcript were derived from different molecules and are biological duplicates - each read should be counted.\nReads with the same UMI originated from the same molecule and are technical duplicates - the UMIs should be collapsed to be counted as a single read.\nIn image below, the reads for ACTB should be collapsed and counted as a single read, while the reads for ARL1 should each be counted.\n\n\nImage credit: modified from Macosko EZ et al. Highly Parallel Genome-wide Expression Profiling of Individual Cells Using Nanoliter Droplets, Cell 2015 (https://doi.org/10.1016/j.cell.2015.05.002)\nSo we know that we need to keep track of the UMIs, but what other information do we need to properly quantify the expression in each gene in each of the cells in our samples? Regardless of droplet method, the following are required for proper quantification at the cellular level:\n\n\nSample index: determines which sample the read originated from (red bottom arrow)\n\nAdded during library preparation - needs to be documented\n\nCellular barcode: determines which cell the read originated from (purple top arrow)\n\nEach library preparation method has a stock of cellular barcodes used during the library preparation\n\nUnique molecular identifier (UMI): determines which transcript molecule the read originated from\n\nThe UMI will be used to collapse PCR duplicates (purple bottom arrow)\n\nSequencing read1: the Read1 sequence (red top arrow)\nSequencing read2: the Read2 sequence (purple bottom arrow)\n\nImage credit: Sarah Boswell, Director of the Single Cell Sequencing Core at HMS",
    "crumbs": [
      "Pre-reading:",
      "Generation of count matrix"
    ]
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-workflow",
    "href": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-workflow",
    "title": "Generation of count matrix",
    "section": "Single-cell RNA-seq workflow",
    "text": "Single-cell RNA-seq workflow\nThe scRNA-seq method will determine how to parse the barcodes and UMIs from the sequencing reads. So, although a few of the specific steps will slightly differ, the overall workflow will generally follow the same steps regardless of method. The general workflow is shown below:\n\nImage credit: Luecken, MD and Theis, FJ. Current best practices in single‐cell RNA‐seq analysis: a tutorial, Mol Syst Biol 2019 (doi: https://doi.org/10.15252/msb.20188746)\nThe steps of the workflow are:\n\nGeneration of the count matrix (method-specific steps): formating reads, demultiplexing samples, mapping and quantification\nQuality control of the raw counts: filtering of poor quality cells\nClustering of filtered counts: clustering cells based on similarities in transcriptional activity (cell types = different clusters)\nMarker identification and cluster annotation: identifying gene markers for each cluster and annotating known cell type clusters\nOptional downstream steps\n\nRegardless of the analysis being done, conclusions about a population based on a single sample per condition are not trustworthy. BIOLOGICAL REPLICATES ARE STILL NEEDED! That is, if you want to make conclusions that correspond to the population and not just the single sample.",
    "crumbs": [
      "Pre-reading:",
      "Generation of count matrix"
    ]
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#generation-of-count-matrix",
    "href": "lessons/02_SC_generation_of_count_matrix.html#generation-of-count-matrix",
    "title": "Generation of count matrix",
    "section": "Generation of count matrix",
    "text": "Generation of count matrix\nWe are going to start by discussing the first part of this workflow, which is generating the count matrix from the raw sequencing data. We will focus on the 3’ end sequencing used by droplet-based methods, such as inDrops, 10X Genomics, and Drop-seq.\n\nAfter sequencing, the sequencing facility will either output the raw sequencing data as BCL or FASTQ format or will generate the count matrix. If the reads are in BCL format, then we will need to convert to FASTQ format. There is a useful command-line tool called bcl2fastq that can easily perform this conversion.\n\n\n\n\n\n\nNote\n\n\n\nWe do not demultiplex at this step in the workflow. You may have sequenced 6 samples, but the reads for all samples may be present all in the same BCL or FASTQ file.\n\n\nThe generation of the count matrix from the raw sequencing data will go through similar steps for many of the scRNA-seq methods.\n\nalevin is a command-line tool that estimates expression of scRNA-seq data for which the 3’ ends of transcripts were sequenced. umi-tools and zUMIs are additional tools that can perform these processes. These tools incorporate collapsing of UMIs to correct for amplification bias. The steps in this process include the following:\n\nFormatting reads and filtering noisy cellular barcodes\nDemultiplexing the samples\nMapping/pseudo-mapping to transcriptome\nCollapsing UMIs and quantification of reads\n\nIf using 10X Genomics library preparation method, then the Cell Ranger pipeline would be used for all of the above steps.\n\n1. Formatting reads and filtering noisy cellular barcodes\nThe FASTQ files can then be used to parse out the cell barcodes, UMIs, and sample barcodes. For droplet-based methods, many of the cellular barcodes will match a low number of reads (&lt; 1000 reads) due to:\n\nencapsulation of free floating RNA from dying cells\nsimple cells (RBCs, etc.) expressing few genes\ncells that failed for some reason\n\nThese excess barcodes need to be filtered out of the sequence data prior to read alignment. To do this filtering, the ‘cellular barcode’ and the ‘molecular barcode’ are extracted and saved for each cell. For example, if using umi-tools, the information is added to the header line for each read, with the following format:\n@HWI-ST808:130:H0B8YADXX:1:1101:2088:2222:CELL_GGTCCA:UMI_CCCT\nAGGAAGATGGAGGAGAGAAGGCGGTGAAAGAGACCTGTAAAAAGCCACCGN\n+\n@@@DDBD&gt;=AFCF+&lt;CAFHDECII:DGGGHGIGGIIIEHGIIIGIIDHII#\nKnown cellular barcodes used in the library preparation method should be known, and unknown barcodes would be dropped, while allowing for an acceptable number of mismatches to the known cellular barcodes.\n\n\n2. Demultiplexing sample reads\nThe next step of the process is to demultiplex the samples, if sequencing more than a single sample. This is the one step of this process not handled by the umi-tools, but is accomplished by zUMIs. We would need to parse the reads to determine the sample barcode associated with each cell.\n\n\n3. Mapping/pseudo-mapping to cDNAs\nTo determine which gene the read originated from, the reads are aligned using traditional (STAR) or light-weight methods (Kallisto/RapMap).\n\n\n4. Collapsing UMIs and quantification of reads\nThe duplicate UMIs are collapsed, and only the unique UMIs are quantified using a tool like Kallisto or featureCounts. The resulting output is a cell by gene matrix of counts:\n\nImage credit: extracted from Lafzi et al. Tutorial: guidelines for the experimental design of single-cell RNA sequencing studies, Nature Protocols 2018 (https://doi.org/10.1038/s41596-018-0073-y)\nEach value in the matrix represents the number of reads in a cell originating from the corresponding gene. Using the count matrix, we can explore and filter the data, keeping only the higher quality cells.",
    "crumbs": [
      "Pre-reading:",
      "Generation of count matrix"
    ]
  },
  {
    "objectID": "schedule/schedule.html",
    "href": "schedule/schedule.html",
    "title": "Introduction to Single-cell RNA-seq Schedule",
    "section": "",
    "text": "Introduction to scRNA-seq\nRaw data to count matrix\nDownload this project\n\n\n\n\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 09:45\nWorkshop introduction\nWill\n\n\n09:45 - 10:35\nIntroduction to Single Cell RNA-sequencing: a practical guide\nDr. Arpita Kulkarni\n\n\n10:35 - 10:40\nBreak\n\n\n\n10:40 - 11:00\nscRNA-seq pre-reading discussion\nAll\n\n\n11:00 - 11:45\nQuality control set-up\nNoor\n\n\n11:45 - 12:00\nOverview of self-learning materials and homework submission\nWill\n\n\n\n\n\nI. Please study the contents and work through all the code within the following lessons:\n\nQuality control of cellranger counts\n\n\nClick here for a preview of this lesson\n\nBefore you start any analysis, it’s important to know whether or not you have good quality cells. At these early stages you can flag or remove samples that could produce erroneous results downstream. In this lesson you will: - Discuss the outputs of cellranger and how to run it  - Review web summary HTML report - Create plots from metrics_summary.csv file \n\nQuality control with additional metrics\n\n\nClick here for a preview of this lesson\n\nIn addition to the QC generated by cellranger, we can also compute some of our own metrics based on the raw data we have loaded into our Seurat object. In this lesson you will: - Compute essential QC metrics for each sample - Create plots to visualize metrics across cells per sample - Critically evaluate each plot and learn what each QC metric means\n\nTheory of PCA\n\n\nClick here for a preview of this lesson\n\nBefore we can begin the next steps of the workflow, we need to make sure you have a good understanding of Principal Components Analysis (PCA). This method will be utilized in the scRNA-seq analysis workflow, and this foundation will help you better navigate those steps and interpretation of results.\n\n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\n\n\nIf you get stuck due to an error while runnning code in the lesson, email us"
  },
  {
    "objectID": "schedule/schedule.html#pre-reading",
    "href": "schedule/schedule.html#pre-reading",
    "title": "Introduction to Single-cell RNA-seq Schedule",
    "section": "",
    "text": "Introduction to scRNA-seq\nRaw data to count matrix\nDownload this project"
  },
  {
    "objectID": "schedule/schedule.html#day-1",
    "href": "schedule/schedule.html#day-1",
    "title": "Introduction to Single-cell RNA-seq Schedule",
    "section": "",
    "text": "Time\nTopic\nInstructor\n\n\n\n\n09:30 - 09:45\nWorkshop introduction\nWill\n\n\n09:45 - 10:35\nIntroduction to Single Cell RNA-sequencing: a practical guide\nDr. Arpita Kulkarni\n\n\n10:35 - 10:40\nBreak\n\n\n\n10:40 - 11:00\nscRNA-seq pre-reading discussion\nAll\n\n\n11:00 - 11:45\nQuality control set-up\nNoor\n\n\n11:45 - 12:00\nOverview of self-learning materials and homework submission\nWill\n\n\n\n\n\nI. Please study the contents and work through all the code within the following lessons:\n\nQuality control of cellranger counts\n\n\nClick here for a preview of this lesson\n\nBefore you start any analysis, it’s important to know whether or not you have good quality cells. At these early stages you can flag or remove samples that could produce erroneous results downstream. In this lesson you will: - Discuss the outputs of cellranger and how to run it  - Review web summary HTML report - Create plots from metrics_summary.csv file \n\nQuality control with additional metrics\n\n\nClick here for a preview of this lesson\n\nIn addition to the QC generated by cellranger, we can also compute some of our own metrics based on the raw data we have loaded into our Seurat object. In this lesson you will: - Compute essential QC metrics for each sample - Create plots to visualize metrics across cells per sample - Critically evaluate each plot and learn what each QC metric means\n\nTheory of PCA\n\n\nClick here for a preview of this lesson\n\nBefore we can begin the next steps of the workflow, we need to make sure you have a good understanding of Principal Components Analysis (PCA). This method will be utilized in the scRNA-seq analysis workflow, and this foundation will help you better navigate those steps and interpretation of results.\n\n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\n\n\nIf you get stuck due to an error while runnning code in the lesson, email us"
  },
  {
    "objectID": "lessons/04_SC_quality_control.html",
    "href": "lessons/04_SC_quality_control.html",
    "title": "Quality Control Analysis",
    "section": "",
    "text": "Approximate time: 90 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control Analysis"
    ]
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#learning-objectives",
    "href": "lessons/04_SC_quality_control.html#learning-objectives",
    "title": "Quality Control Analysis",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nConstruct quality control metrics and visually evaluate the quality of the data\nApply appropriate filters to remove low quality cells",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control Analysis"
    ]
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#generating-quality-metrics",
    "href": "lessons/04_SC_quality_control.html#generating-quality-metrics",
    "title": "Quality Control Analysis",
    "section": "Generating quality metrics",
    "text": "Generating quality metrics\nWhen data is loaded into Seurat and the initial object is created, there is some basic metadata asssembled for each of the cells in the count matrix. To take a close look at this metadata, let’s view the data frame stored in the obs slot of our adata object:\n\nimport scanpy as sc\nimport seaborn as sns\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nadata = sc.read_h5ad(\"../results/03_merge.h5ad\")\nadata.obs.head()\n\n\n\n\n\n\n\n\nn_genes\nsample\n\n\n\n\nAAACATACAATGCC-1_ctrl\n874\nctrl\n\n\nAAACATACATTTCC-1_ctrl\n896\nctrl\n\n\nAAACATACCAGAAA-1_ctrl\n725\nctrl\n\n\nAAACATACCAGCTA-1_ctrl\n979\nctrl\n\n\nAAACATACCATGCA-1_ctrl\n362\nctrl\n\n\n\n\n\n\n\nIn order to create the appropriate plots for the quality control analysis, we need to calculate some additional metrics. These include:\n\nNumber of counts per cell total counts in a cell\nNumber of genes detected per UMI: this metric with give us an idea of the complexity of our dataset (more genes detected per UMI, more complex our data)\nMitochondrial ratio: this metric will give us a percentage of cell reads originating from the mitochondrial genes\n\nTo calculate these values, we can use the calculate_qc_metrics() function to automatically generate scores for each cell.\n\nsc.pp.calculate_qc_metrics(adata,\n                           percent_top=None,\n                           log1p=False,\n                           inplace=True)\nadata.obs.head()\n\n\n\n\n\n\n\n\nn_genes\nsample\nn_genes_by_counts\ntotal_counts\n\n\n\n\nAAACATACAATGCC-1_ctrl\n874\nctrl\n874\n2344.0\n\n\nAAACATACATTTCC-1_ctrl\n896\nctrl\n896\n3125.0\n\n\nAAACATACCAGAAA-1_ctrl\n725\nctrl\n725\n2578.0\n\n\nAAACATACCAGCTA-1_ctrl\n979\nctrl\n979\n3261.0\n\n\nAAACATACCATGCA-1_ctrl\n362\nctrl\n362\n746.0",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control Analysis"
    ]
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#cell-counts",
    "href": "lessons/04_SC_quality_control.html#cell-counts",
    "title": "Quality Control Analysis",
    "section": "Cell counts",
    "text": "Cell counts\nThe cell counts are determined by the number of unique cellular barcodes detected. For this experiment, between 12,000 -13,000 cells are expected.\nIn an ideal world, you would expect the number of unique cellular barcodes to correpsond to the number of cells you loaded. However, this is not the case as capture rates of cells are only a proportion of what is loaded. For example, the inDrops cell capture efficiency is higher (70-80%) compared to 10X which is between 50-60%.\n\n\n\n\n\n\nNote\n\n\n\nThe capture efficiency could appear much lower if the cell concentration used for library preparation was not accurate. Cell concentration should NOT be determined by FACS machine or Bioanalyzer (these tools are not accurate for concentration determination), instead use a hemocytometer or automated cell counter for calculation of cell concentration._\n\n\nThe cell numbers can also vary by protocol, producing cell numbers that are much higher than what we loaded. For example, during the inDrops protocol, the cellular barcodes are present in the hydrogels, which are encapsulated in the droplets with a single cell and lysis/reaction mixture. While each hydrogel should have a single cellular barcode associated with it, occasionally a hydrogel can have more than one cellular barcode. Similarly, with the 10X protocol there is a chance of obtaining only a barcoded bead in the emulsion droplet (GEM) and no actual cell. Both of these, in addition to the presence of dying cells can lead to a higher number of cellular barcodes than cells.\n\nax = sns.countplot(data=adata.obs, \n                   x=\"sample\",\n                   hue=\"sample\")\nax.set_title(\"NCells\")\n\nText(0.5, 1.0, 'NCells')\n\n\n\n\n\n\n\n\n\nWe see over 15,000 cells per sample, which is quite a bit more than the 12-13,000 expected. It is clear that we likely have some junk ‘cells’ present.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control Analysis"
    ]
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#umi-counts-transcripts-per-cell",
    "href": "lessons/04_SC_quality_control.html#umi-counts-transcripts-per-cell",
    "title": "Quality Control Analysis",
    "section": "UMI counts (transcripts) per cell",
    "text": "UMI counts (transcripts) per cell\nThe UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply.\n\nax = sns.histplot(data=adata.obs,\n                  x=\"total_counts\",\n                  hue=\"sample\",\n                  kde=True,\n                  log_scale=True,\n                  alpha=0.2)\nax.axvline(500, color=\"black\")\nax.set_title(\"Total Counts\")\n\nText(0.5, 1.0, 'Total Counts')\n\n\n\n\n\n\n\n\n\nWe can see that majority of our cells in both samples have 1000 UMIs or greater, which is great.\n\nGenes detected per cell\nWe have similar expectations for gene detection as for UMI detection, although it may be a bit lower than UMIs. For high quality data, the proportional histogram should contain a single large peak that represents cells that were encapsulated. If we see a small shoulder to the left of the major peak (not present in our data), or a bimodal distribution of the cells, that can indicate a couple of things. It might be that there are a set of cells that failed for some reason. It could also be that there are biologically different types of cells (i.e. quiescent cell populations, less complex cells of interest), and/or one type is much smaller than the other (i.e. cells with high counts may be cells that are larger in size). Therefore, this threshold should be assessed with other metrics that we describe in this lesson.\n\nax = sns.histplot(data=adata.obs,\n                  x=\"n_genes\",\n                  hue=\"sample\",\n                  kde=True,\n                  log_scale=True,\n                  alpha=0.2)\nax.axvline(300, color=\"black\")\nax.set_title(\"Genes per Cell\")\n\nText(0.5, 1.0, 'Genes per Cell')\n\n\n\n\n\n\n\n\n\n\n\nComplexity\nWe can evaluate each cell in terms of how complex the RNA species are by using a measure called the novelty score. The novelty score is computed by taking the ratio of nGenes over nUMI. If there are many captured transcripts (high nUMI) and a low number of genes detected in a cell, this likely means that you only captured a low number of genes and simply sequenced transcripts from those lower number of genes over and over again. These low complexity (low novelty) cells could represent a specific cell type (i.e. red blood cells which lack a typical transcriptome), or could be due to an artifact or contamination. Generally, we expect the novelty score to be above 0.80 for good quality cells.\n\nadata.obs[\"log10GenesPerUMI\"] = np.log10(adata.obs[\"n_genes\"]) / np.log10(adata.obs[\"total_counts\"])\nadata.obs.head()\n\n\n\n\n\n\n\n\nn_genes\nsample\nn_genes_by_counts\ntotal_counts\nlog10GenesPerUMI\n\n\n\n\nAAACATACAATGCC-1_ctrl\n874\nctrl\n874\n2344.0\n0.872863\n\n\nAAACATACATTTCC-1_ctrl\n896\nctrl\n896\n3125.0\n0.844760\n\n\nAAACATACCAGAAA-1_ctrl\n725\nctrl\n725\n2578.0\n0.838493\n\n\nAAACATACCAGCTA-1_ctrl\n979\nctrl\n979\n3261.0\n0.851262\n\n\nAAACATACCATGCA-1_ctrl\n362\nctrl\n362\n746.0\n0.890686\n\n\n\n\n\n\n\n\nax = sns.histplot(data=adata.obs,\n                  x=\"log10GenesPerUMI\",\n                  hue=\"sample\",\n                  kde=True,\n                  alpha=0.2)\nax.axvline(0.8, color=\"black\")\nax.set_title(\"Genes per Cell\")\n\nText(0.5, 1.0, 'Genes per Cell')\n\n\n\n\n\n\n\n\n\n\n\nMitochondrial Ratio\nSeurat has a convenient function that allows us to calculate the proportion of transcripts mapping to mitochondrial genes. The PercentageFeatureSet() function takes in a pattern argument and searches through all gene identifiers in the dataset for that pattern. Since we are looking for mitochondrial genes, we are searching any gene identifiers that begin with the pattern “MT-”. For each cell, the function takes the sum of counts across all genes (features) belonging to the “Mt-” set, and then divides by the count sum for all genes (features). This value is multiplied by 100 to obtain a percentage value.\n\n\n\n\n\n\nNote\n\n\n\nFor our analysis, rather than using a percentage value we would prefer to work with the ratio value. As such, we will reverse that last step performed by the function by taking the output value and dividing by 100.\n\n\n\nmito_genes = adata.var_names.str.startswith('MT-')\nadata.var['mito'] = mito_genes\nadata.var.head()\n\n\n\n\n\n\n\n\ngene_ids\nfeature_types\nn_cells_by_counts\nmean_counts\npct_dropout_by_counts\ntotal_counts\nmito\n\n\n\n\nMIR1302-2HG\nENSG00000243485\nGene Expression\n0\n0.000000\n100.000000\n0.0\nFalse\n\n\nFAM138A\nENSG00000237613\nGene Expression\n0\n0.000000\n100.000000\n0.0\nFalse\n\n\nOR4F5\nENSG00000186092\nGene Expression\n0\n0.000000\n100.000000\n0.0\nFalse\n\n\nAL627309.1\nENSG00000238009\nGene Expression\n12\n0.000382\n99.961837\n12.0\nFalse\n\n\nAL627309.3\nENSG00000239945\nGene Expression\n1\n0.000032\n99.996820\n1.0\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe pattern provided (“^MT-”) works for human gene names. You may need to adjust the pattern argument depending on your organism of interest. Additionally, if you weren’t using gene names as the gene ID then this function wouldn’t work as we have used it above as the pattern will not suffice. Since there are caveats to using this function, it is advisable to manually compute this metric. If you are interested, we have code available to compute this metric on your own.\n\n\n\nsc.pp.calculate_qc_metrics(adata, \n                           qc_vars=(\"mito\"), \n                           inplace=True)\nadata.obs.head()\n\n\n\n\n\n\n\n\nn_genes\nsample\nn_genes_by_counts\ntotal_counts\nlog10GenesPerUMI\nlog1p_n_genes_by_counts\nlog1p_total_counts\npct_counts_in_top_50_genes\npct_counts_in_top_100_genes\npct_counts_in_top_200_genes\npct_counts_in_top_500_genes\ntotal_counts_mito\nlog1p_total_counts_mito\npct_counts_mito\n\n\n\n\nAAACATACAATGCC-1_ctrl\n874\nctrl\n874\n2344.0\n0.872863\n6.774224\n7.760041\n47.568259\n59.129693\n69.197952\n84.044369\n46.0\n3.850147\n1.962457\n\n\nAAACATACATTTCC-1_ctrl\n896\nctrl\n896\n3125.0\n0.844760\n6.799056\n8.047509\n51.904000\n63.456000\n74.080000\n87.328000\n56.0\n4.043051\n1.792000\n\n\nAAACATACCAGAAA-1_ctrl\n725\nctrl\n725\n2578.0\n0.838493\n6.587550\n7.855157\n61.947246\n69.550039\n78.432894\n91.272304\n40.0\n3.713572\n1.551590\n\n\nAAACATACCAGCTA-1_ctrl\n979\nctrl\n979\n3261.0\n0.851262\n6.887553\n8.090096\n52.836553\n62.557498\n71.879791\n85.311254\n45.0\n3.828641\n1.379945\n\n\nAAACATACCATGCA-1_ctrl\n362\nctrl\n362\n746.0\n0.890686\n5.894403\n6.616065\n53.887399\n64.879357\n78.284182\n100.000000\n16.0\n2.833213\n2.144772\n\n\n\n\n\n\n\n\n# We want the value as a ratio\nadata.obs[\"mito_ratio\"] = adata.obs[\"pct_counts_mito\"] / 100\n\nax = sns.histplot(data=adata.obs,\n                  x=\"mito_ratio\",\n                  hue=\"sample\",\n                  kde=True,\n                  alpha=0.2)\nax.axvline(0.2, color=\"black\")\nax.set_title(\"Mitochondrial Ratio\")\n\nText(0.5, 1.0, 'Mitochondrial Ratio')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReads per cell\n\n\n\nThis is another metric that can be useful to explore; however, the workflow used would need to save this information to assess. Generally, with this metric you hope to see all of the samples with peaks in relatively the same location between 10,000 and 100,000 reads per cell.\n\n\n\n\nJoint filtering effects\nConsidering any of these QC metrics in isolation can lead to misinterpretation of cellular signals. For example, cells with a comparatively high fraction of mitochondrial counts may be involved in respiratory processes and may be cells that you would like to keep. Likewise, other metrics can have other biological interpretations. A general rule of thumb when performing QC is to set thresholds for individual metrics to be as permissive as possible, and always consider the joint effects of these metrics. In this way, you reduce the risk of filtering out any viable cell populations.\nTwo metrics that are often evaluated together are the number of UMIs and the number of genes detected per cell. Here, we have plotted the number of genes versus the number of UMIs coloured by the fraction of mitochondrial reads. Jointly visualizing the count and gene thresholds and additionally overlaying the mitochondrial fraction, gives a summarized persepective of the quality per cell.\n\ng = sns.FacetGrid(adata.obs, col=\"sample\")\ng.map_dataframe(sns.scatterplot, \n                x=\"total_counts\", \n                y=\"n_genes\", \n                hue=\"mito_ratio\",\n                palette=\"viridis\")\n\n# Log10 scale x- and y-axis\nfor ax in g.axes.flat:\n    ax.set(xscale=\"log\", yscale=\"log\")\n\n# Add lines\ng.refline(x=500, y=300)\n\n# Add colorbar legend\nsm = g.axes[0, 0].collections[0]\nplt.colorbar(sm, \n             ax=g.axes, \n             label=\"mito_ratio\")",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control Analysis"
    ]
  },
  {
    "objectID": "lessons/04_cellranger_QC.html",
    "href": "lessons/04_cellranger_QC.html",
    "title": "Quality Control of Cellranger Output",
    "section": "",
    "text": "Approximate time: 30 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control of Cellranger Output"
    ]
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#learning-objectives",
    "href": "lessons/04_cellranger_QC.html#learning-objectives",
    "title": "Quality Control of Cellranger Output",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe how cellranger is run and what the ouputs are\nReview the cellranger generated QC report (web summary HTML)\nCreate plots with cellranger metrics",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control of Cellranger Output"
    ]
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#cellranger",
    "href": "lessons/04_cellranger_QC.html#cellranger",
    "title": "Quality Control of Cellranger Output",
    "section": "Cellranger",
    "text": "Cellranger\nCellranger is a tool created by the company 10x to process single-cell sequencing experiments that were processed with their kits.\nThe algorithm for the single-cell RNA-seq (scRNA) version of cellranger is described by 10x as follows:\n\nImage credit: 10x\nThe main elements of this pipeline are as follows:\n\nAlign FASTQ reads against a reference genome\nFilter low quailty reads and correct cell barcodes/UMIs\nCollapse on PCR duplicates using UMIs\nGenerate raw counts matrix\nIdentify low quality cells to generate a filtered counts matrix\n\nWhile the focus of this workshop is scRNA, we also want to point out that there are other cellranger softwares and modes for different types of single-cell experiments.\n\n\n\nExperiment\nExperiment description\n10x tool\n\n\n\n\nRNA\nRNA\ncellranger count\n\n\nATAC\nATAC\ncellranger-atac count\n\n\nMultiome\nRNA + ATAC\ncellranger-arc count\n\n\nV(D)J\nClonotyping of T and B cells\ncellranger vdj\n\n\nHashtagging\nAntibody/oligo tags to differentiate cells after pooling\ncellranger multi",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control of Cellranger Output"
    ]
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#running-cellranger-on-o2",
    "href": "lessons/04_cellranger_QC.html#running-cellranger-on-o2",
    "title": "Quality Control of Cellranger Output",
    "section": "Running Cellranger on O2",
    "text": "Running Cellranger on O2\nRunning cellranger requires a lot of time and computational resources in order to process a single sample. Therefore, having access to a High Performance Computing (HPC) cluster is necessary to run it. Some sequencing cores will automatically process samples with cellranger and provide the outputs to you.\nNote that prior to this step, you must have a cellranger compatible reference genome generated. If you are working with mouse or human, 10x has pre-generated the reference which can be downloaded from their website for use. If you are using another organism, cellranger has a mode called mkref which will generate everything needed for a reference from the files you supply (GTF and fasta).\nHere we are showing an example of how to run cellranger count on Harvard’s O2 HPC using SLURM. To run this script, you will have add additional information, such as:\n\nThe name of the project (the results will be placed in a folder of the same name)\nPath to the FASTQ files from your experiment\nPath to the reference genome\n\nIn the following example script, you would just have to change the variable specified in the “Inputs for cellranger” section on eth 10x support site. We have already provided some optimal parameters in terms of runtime and memory for running cellranger count.\nYou do not need to run this script.\n\n#SBATCH --partition=short               # Partition name\n#SBATCH --time=0-06:00                  # Runtime in D-HH:MM format\n#SBATCH --nodes=1                       # Number of nodes (keep at 1)\n#SBATCH --ntasks=1                      # Number of tasks per node (keep at 1)\n#SBATCH --cpus-per-task=16              # CPU cores requested per task (change for threaded jobs)\n#SBATCH --mem=64G                       # Memory needed per node (total)\n#SBATCH --error=jobid_%j.err            # File to which STDERR will be written, including job ID\n#SBATCH --output=jobid_%j.out           # File to which STDOUT will be written, including job ID\n#SBATCH --mail-type=ALL                 # Type of email notification (BEGIN, END, FAIL, ALL)\n\nmodule load gcc\nmodule load cellranger/7.1.0\n\nlocal_cores=16\nlocal_mem=64\n\n# Inputs for cellranger\nproject_name=\"\"                         # Name of output\npath_fastq=\"/path/to/fastq/\"             # Path to folder with FASTQ files for one sample\npath_ref=\"/path/to/reference/\"           # Path to cellranger compatible reference\n\n\ncellranger count \\\n    --id=${project_name} \\\n    --fastqs=${path_fastq} \\\n    --transcriptome=${path_ref} \\\n    --localcores=${local_cores} \\\n    --localmem=${local_mem}\n\n\n  Cell In[2], line 11\n    module load gcc\n           ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control of Cellranger Output"
    ]
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#cellranger-outs",
    "href": "lessons/04_cellranger_QC.html#cellranger-outs",
    "title": "Quality Control of Cellranger Output",
    "section": "Cellranger outs",
    "text": "Cellranger outs\nOnce cellranger has finished running, there will be a folder titled outs/ in a directory named after the project_name variable set above. Generation of all the following files is expected from a succesful completion of the cellranger counts pipeline:\n\n├── cloupe.cloupe\n├── filtered_feature_bc_matrix\n│   ├── barcodes.tsv.gz\n│   ├── features.tsv.gz\n│   └── matrix.mtx.gz\n├── filtered_feature_bc_matrix.h5\n├── metrics_summary.csv\n├── molecule_info.h5\n├── possorted_genome_bam.bam\n├── possorted_genome_bam.bam.bai\n├── raw_feature_bc_matrix\n│   ├── barcodes.tsv.gz\n│   ├── features.tsv.gz\n│   └── matrix.mtx.gz\n├── raw_feature_bc_matrix.h5\n└── web_summary.html\n\n\n  Cell In[3], line 1\n    ├── cloupe.cloupe\n    ^\nSyntaxError: invalid character '├' (U+251C)",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control of Cellranger Output"
    ]
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#web-summary-html-report",
    "href": "lessons/04_cellranger_QC.html#web-summary-html-report",
    "title": "Quality Control of Cellranger Output",
    "section": "Web summary HTML Report",
    "text": "Web summary HTML Report\nThe Web Summary HTML file is a great resource for looking at the basic quality of your sample before starting on an analysis. 10x has a page describing each metric in depth. There are two pages/tabs included in a scRNA report titled “Summary” and “Gene Expression”.\nWe have included these Web Summary files for the control and stimulated samples as links below. You can download each, and move the HTML to your project data folder:\n\nControl sample report\nStimulated sample report\n\n\n\n\n\n\n\nNote\n\n\n\nSome of the values in these reports will be slightly different from current standards, as these samples were generated using the version 1 chemistry kit and optimization have been made since then.\n\n\n\nSummary\nAt the top of the “Summary” tab, under the “Alerts” header, will be a list of warnings and messages on the quality/important information about the sample. These messages are very informative on what may have gone wrong with the sample or other flags that can be set in the cellranger count run to gain better results.\nUnderneath the “Alerts” header, in green text, are the estimated number of high quality cells in the sample, average reads per cells, and median genes per cell. The number of cells will vary depending on how many were loaded in sample preparation, but some general recommendations are provided below:\n\n500 cells is the lower limit for a good quality sample.\n10x also recommends a minimum of 20,000 reads per cell on average.\nThe median genes per cell varies widely across samples as it depends on sequencing depth and cell type, making it difficult to establish a good minimal value.\n\nThe remaining 4 sections include various metrics that describe the overall quality of the sample. Note that clicking on the grey question mark will show more detailed explanations.\nSequencing\nIncludes information such as the total number of reads and how many of those reads did not meet the length requirements. Additionally, since all barcodes and UMIs are known values (from the kit used to prep scRNA experiments), we can evaluate what percentage of the barcodes and UMIs belong to that whitelist and are valid.\n\nIdeally, you would like to see &gt;75% for almost all of these values since lower values are indicative of a low quality sequencing run or bad sample quality.\nMapping\nPercentage of reads that map to different regions of the reference genome as reported by STAR.\n\nThe percent of reads mapped to the genome should be on the higher end, around 85% or higher. Values that are very low could indicate that the reference genome supplied was incorrect or that the sample was problematic. Otherwise, the expectation for a scRNA runs is that the majority of reads will belong to exonic regions. If nuclei were used instead of whole cells, the percentage of reads mapping to intronic regions will be higher (~45%).\nCells\nHere we can see what an ideal representation of the Barcode Rank Plot looks like. The cells are sorted by the number of UMIs found in the cell to differentiate empty droplets/low quality cells (background) from actual cells.\n\nImage credit: 10x\nThe shape of these plots can indicate a few different things about the sample:\n\nTypical: Clear cliff and knee with separation between cells and background.\nHeterogeneous: Bimodal plot with 2 cliffs and knees, with a clear divide between cells and background.\nCompromised: Round curve with a steep drop-off at the end whih indicated low quality due to many factors.\nCompromised: Defined cliff and knee, but with few barcodes detected could be due to inaccurate cell count or clogging.\n\nThis section additionally describes averages and medians for number of genes and reads in the sample.\nSample\nThe sample section contains important metadata used by cellranger, such as what the Sample ID and the path used for the reference. The chemistry version (which 10x kit was used) and intron flags are also stored here. This information is useful for reproducibility reasons, as the version of cellranger used is also kept.\n\n\n\nGene Expression\nThe “Gene Expression” table contains information downstream of the basic QC, such as:\nt-SNE Projection\nDotplot showing the t-SNE projection of filtered cells colored by UMI counts and clusters. The report allows you select various values of K for the K-means clustering, showing different groupings that can be generated from the data.\n\nLater in the workshop we will spend more time on the intricacies of clustering. The requirements for this QC report would be to see clear separation of cells into groups with defined clusters - representing different cell types.\nTop Features by Cluster\nThis table shows the log2 fold-change and p-value for each gene and cluster after a differential expression analysis is run.\n\nThese top genes per cluster can give a brief peek into the cell type distribution of the sample. If no expected cell type marker genes appear or mitochondrial/ribosomal genes show up frequently, this can be indicative of something wrong with the sample.\nSequencing Saturation and Median Genes per Cell\nThe sequencing saturation plot is a measure of library complexity. In scRNA, more genes can be detected with higher sequencing depth. At a point, you reach sequencing saturation where you do not gain any more meaningful insights which is what the dotted line represents here.\nSimilar to the sequencing saturation plot, looking at the median gene per cells against mean reads per cell will indicate if your have over or under-sequenced. The slope near the endpoint can be used to determine how much benefit would be gained from sequencing more deeply.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control of Cellranger Output"
    ]
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#metrics-evaluation",
    "href": "lessons/04_cellranger_QC.html#metrics-evaluation",
    "title": "Quality Control of Cellranger Output",
    "section": "Metrics evaluation",
    "text": "Metrics evaluation\nMany of the core pieces of information from the web summary are stored in the metrics_summary.csv. As this is a csv file, we can read it into R and generate plots to include in reports on the general quality of the samples.\nWe have included these csv files for the control and stimulated samples as links below. You can right-click on the link and “Save as…” into your project data folder:\n\nControl sample metrics.csv file\nStimulated sample metrics.csv file\n\nFirst, to read the files in:\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n\n\nsample_names = [\"ctrl\", \"stim\"]\nsample = \"stim\"\nmetrics = pd.read_csv(f\"../data/{sample}_metrics_summary.csv\")\nmetrics = metrics.transpose()\nmetrics[0] = metrics[0].str.replace(\"%\", \"\")\nmetrics[0] = metrics[0].str.replace(\",\", \"\")\n\nmetrics\n\n\n\n\n\n\n\n\n0\n\n\n\n\nEstimated Number of Cells\n15288\n\n\nMean Reads per Cell\n9823\n\n\nMedian Genes per Cell\nNaN\n\n\nNumber of Reads\n150179402\n\n\nValid Barcodes\n99.4\n\n\nSequencing Saturation\n74.5\n\n\nQ30 Bases in Barcode\n62.1\n\n\nQ30 Bases in RNA Read\n72.6\n\n\nQ30 Bases in UMI\n87.2\n\n\nReads Mapped to Genome\n96.7\n\n\nReads Mapped Confidently to Genome\n95.2\n\n\nReads Mapped Confidently to Intergenic Regions\n1.8\n\n\nReads Mapped Confidently to Intronic Regions\n13.4\n\n\nReads Mapped Confidently to Exonic Regions\n80.1\n\n\nReads Mapped Confidently to Transcriptome\n88.3\n\n\nReads Mapped Antisense to Gene\n4.7\n\n\nFraction Reads in Cells\n96.7\n\n\nTotal Genes Detected\n25268\n\n\nMedian UMI Counts per Cell\n1616",
    "crumbs": [
      "Day 1 Self-learning:",
      "Quality Control of Cellranger Output"
    ]
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html",
    "href": "lessons/01_intro_to_scRNA-seq.html",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "Across human tissues there is an incredible diversity of cell types, states, and interactions. To better understand these tissues and the cell types present, single-cell RNA-seq (scRNA-seq) offers a glimpse into what genes are being expressed at the level of individual cells.\n\nImage credit: courtesy of Dr. Ayshwarya Subramanian\nThis exciting and cutting-edge method can be used to:\n\nExplore which cell types are present in a tissue\nIdentify unknown/rare cell types or states\nElucidate the changes in gene expression during differentiation processes or across time or states\nIdentify genes that are differentially expressed in particular cell types between conditions (e.g. treatment or disease)\nExplore changes in expression among a cell type while incorporating spatial, regulatory, and/or protein information\n\nPopular methods to address some of the more common investigations include:\n\n\n\n\nPrior to scRNA-seq, transcriptome analysis was performed using bulk RNA-seq, which is a method for comparing the averages of cellular expression. This method can be a good choice if looking at comparative transcriptomics (e.g. samples of the same tissue from different species), and for quantifying expression signatures in disease studies. It also has potential for the discovery of disease biomarkers if you are not expecting or not concerned about cellular heterogeneity in the sample.\nWhile bulk RNA-seq can explore differences in gene expression between conditions (e.g. treatment or disease), the differences at the cellular level are not adequately captured. For instance, in the images below, if analyzed in bulk (left) we would not detect the correct association between the expression of gene A and gene B. However, if we properly group the cells by cell type or cell state, we can see the correct correlation between the genes.\n\nImage credit: Trapnell, C. Defining cell types and states with single-cell genomics, Genome Research 2015 (doi: https://dx.doi.org/10.1101/gr.190595.115)\nDespite scRNA-seq being able to capture expression at the cellular level, sample generation and library preparation is more expensive and the analysis is much more complicated and more difficult to interpret. The complexity of analysis of scRNA-seq data involves:\n\nLarge volume of data\nLow depth of sequencing per cell\nTechnical variability across cells/samples\nBiological variability across cells/samples\n\nWe will explore each of these complexities in more detail below:\n\n\nExpression data from scRNA-seq experiments represent tens or hundreds of thousands of reads for thousands of cells. The data output is much larger, requiring higher amounts of memory to analyze, larger storage requirements, and more time to run the analyses.\n\n\n\nFor the droplet-based methods of scRNA-seq, the depth of sequencing is shallow, often detecting only 10-50% of the transcriptome per cell. This results in cells showing zero counts for many of the genes. However, in a particular cell, a zero count for a gene could either mean that the gene was not being expressed or the transcripts were just not detected. Across cells, genes with higher levels of expression tend to have fewer zeros. Due to this feature, many genes will not be detected in any cell and gene expression will be highly variable between cells.\n\n\n\n\n\n\nZero-inflated?\n\n\n\nscRNA-seq data is often referred to as zero-inflated; however, recent analyses suggest that it does not contain more zeros than what would be expected given the sequencing depth [Valentine Svensson’s blog post]. A more recent paper discussing modeling of scRNA-seq data is also available.\n\n\n\n\n\nUninteresting sources of biological variation can result in gene expression between cells being more similar/different than the actual biological cell types/states, which can obscure the cell type identities. Uninteresting sources of biological variation (unless part of the experiment’s study) include:\n\nTranscriptional bursting: Gene transcription is not turned on all of the time for all genes. Time of harvest will determine whether gene is on or off in each cell.\nVarying rates of RNA processing: Different RNAs are processed at different rates.\nContinuous or discrete cell identities (e.g. the pro-inflammatory potential of each individual T cell): Continuous phenotypes are by definition variable in gene expression, and separating the continuous from the discrete can sometimes be difficult.\nEnvironmental stimuli: The local environment of the cell can influence the gene expression depending on spatial position, signaling molecules, etc.\nTemporal changes: Fundamental fluxuating cellular processes, such as cell cycle, can affect the gene expression profiles of individual cells.\n\n\nImage credit: Wagner, A, et al. Revealing the vectors of cellular identity with single-cell genomics, Nat Biotechnol. 2016 (doi:https://dx.doi.org/10.1038%2Fnbt.3711)\n\n\n\nTechnical sources of variation can result in gene expression between cells being more similar/different based on technical sources instead of biological cell types/states, which can obscure the cell type identities. Technical sources of variation include:\n\nCell-specific capture efficiency: Different cells will have differing numbers of transcripts captured resulting in differences in sequencing depth (e.g. 10-50% of transcriptome).\nLibrary quality: Degraded RNA, low viability/dying cells, lots of free floating RNA, poorly dissociated cells, and inaccurate quantitation of cells can result in low quality metrics\nAmplification bias: During the amplification step of library preparation, not all transcripts are amplified to the same level.\nBatch effects: Batch effects are a significant issue for scRNA-Seq analyses, since you can see significant differences in expression due solely to the batch effect.\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nTo explore the issues generated by poor batch study design, they are highlighted nicely in this paper.\nHow to know whether you have batches?\n\nWere all RNA isolations performed on the same day?\nWere all library preparations performed on the same day?\nDid the same person perform the RNA isolation/library preparation for all samples?\nDid you use the same reagents for all samples?\nDid you perform the RNA isolation/library preparation in the same location?\n\nIf any of the answers is ‘No’, then you have batches.\nBest practices regarding batches:\n\nDesign the experiment in a way to avoid batches, if possible.\nIf unable to avoid batches:\n\nDo NOT confound your experiment by batch:\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO split replicates of the different sample groups across batches. The more replicates the better (definitely more than 2), if doing DE across conditions or making conclusions at the population level. If using inDrops, which prepares a single library at a time, alternate the sample groups (e.g. don’t prepare all control libraries first, then prepare all treatment libraries).\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO include batch information in your experimental metadata. During the analysis, we can regress out variation due to batch or integrate across batches, so it doesn’t affect our results if we have that information.\n\n\n\n\n\n\n\nWhile scRNA-seq is a powerful and insightful method for the analysis of gene expression with single-cell resolution, there are many challenges and sources of variation that can make the analysis of the data complex or limited. Throughout the analysis of scRNA-seq data, we will try to account for or regress out variation due to the various sources of uninteresting variation in our data.\nOverall, we recommend the following:\n\nDo not perform single-cell RNA-seq unless it is necessary for the experimental question of interest. Could you answer the question using bulk sequencing, which is simpler and less costly? Perhaps FACS sorting the samples could allow for bulk analysis?\nUnderstand the details of the experimental question you wish to address. The recommended library preparation method and analysis workflow can vary based on the specific experiment.\nAvoid technical sources of variability, if possible:\n\nDiscuss experimental design with experts prior to the initiation of the experiment\nIsolate RNA from samples at same time\nPrepare libraries at same time or alternate sample groups to avoid batch confounding\nDo not confound sample groups by sex, age, or batch\n\n\n\n\n\n\n\n\n\nHow does single-nucleus RNA-seq (snRNA-seq) compare to single-cell RNA-seq?\n\n\n\nWe will not be covering snRNA-seq in this workshop! Below is a brief overview of snRNA-seq.\nsnRNA-seq analyzes the expression profiles from nuclei, instead of intact cells. As you may expect, fewer transcripts are detected from the nuclei (~7,000 genes), compared to intact cells (~11,000 genes). In some situations (depending on your research materials and goals), snRNA-seq can be the preferred method as opposed to scRNA-seq.\nSome advantages of snRNA-seq include:\n\nWorks well with hard-to-isolate samples (for example, adipocytes), as well as frozen tissues\nReduces transcriptional artifacts from the isolation process\nProvides less biased cellular coverage",
    "crumbs": [
      "Pre-reading:",
      "Introduction to single-cell RNA-seq"
    ]
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html#why-single-cell-rna-seq",
    "href": "lessons/01_intro_to_scRNA-seq.html#why-single-cell-rna-seq",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "Across human tissues there is an incredible diversity of cell types, states, and interactions. To better understand these tissues and the cell types present, single-cell RNA-seq (scRNA-seq) offers a glimpse into what genes are being expressed at the level of individual cells.\n\nImage credit: courtesy of Dr. Ayshwarya Subramanian\nThis exciting and cutting-edge method can be used to:\n\nExplore which cell types are present in a tissue\nIdentify unknown/rare cell types or states\nElucidate the changes in gene expression during differentiation processes or across time or states\nIdentify genes that are differentially expressed in particular cell types between conditions (e.g. treatment or disease)\nExplore changes in expression among a cell type while incorporating spatial, regulatory, and/or protein information\n\nPopular methods to address some of the more common investigations include:",
    "crumbs": [
      "Pre-reading:",
      "Introduction to single-cell RNA-seq"
    ]
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html#challenges-of-scrna-seq-analysis",
    "href": "lessons/01_intro_to_scRNA-seq.html#challenges-of-scrna-seq-analysis",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "Prior to scRNA-seq, transcriptome analysis was performed using bulk RNA-seq, which is a method for comparing the averages of cellular expression. This method can be a good choice if looking at comparative transcriptomics (e.g. samples of the same tissue from different species), and for quantifying expression signatures in disease studies. It also has potential for the discovery of disease biomarkers if you are not expecting or not concerned about cellular heterogeneity in the sample.\nWhile bulk RNA-seq can explore differences in gene expression between conditions (e.g. treatment or disease), the differences at the cellular level are not adequately captured. For instance, in the images below, if analyzed in bulk (left) we would not detect the correct association between the expression of gene A and gene B. However, if we properly group the cells by cell type or cell state, we can see the correct correlation between the genes.\n\nImage credit: Trapnell, C. Defining cell types and states with single-cell genomics, Genome Research 2015 (doi: https://dx.doi.org/10.1101/gr.190595.115)\nDespite scRNA-seq being able to capture expression at the cellular level, sample generation and library preparation is more expensive and the analysis is much more complicated and more difficult to interpret. The complexity of analysis of scRNA-seq data involves:\n\nLarge volume of data\nLow depth of sequencing per cell\nTechnical variability across cells/samples\nBiological variability across cells/samples\n\nWe will explore each of these complexities in more detail below:\n\n\nExpression data from scRNA-seq experiments represent tens or hundreds of thousands of reads for thousands of cells. The data output is much larger, requiring higher amounts of memory to analyze, larger storage requirements, and more time to run the analyses.\n\n\n\nFor the droplet-based methods of scRNA-seq, the depth of sequencing is shallow, often detecting only 10-50% of the transcriptome per cell. This results in cells showing zero counts for many of the genes. However, in a particular cell, a zero count for a gene could either mean that the gene was not being expressed or the transcripts were just not detected. Across cells, genes with higher levels of expression tend to have fewer zeros. Due to this feature, many genes will not be detected in any cell and gene expression will be highly variable between cells.\n\n\n\n\n\n\nZero-inflated?\n\n\n\nscRNA-seq data is often referred to as zero-inflated; however, recent analyses suggest that it does not contain more zeros than what would be expected given the sequencing depth [Valentine Svensson’s blog post]. A more recent paper discussing modeling of scRNA-seq data is also available.\n\n\n\n\n\nUninteresting sources of biological variation can result in gene expression between cells being more similar/different than the actual biological cell types/states, which can obscure the cell type identities. Uninteresting sources of biological variation (unless part of the experiment’s study) include:\n\nTranscriptional bursting: Gene transcription is not turned on all of the time for all genes. Time of harvest will determine whether gene is on or off in each cell.\nVarying rates of RNA processing: Different RNAs are processed at different rates.\nContinuous or discrete cell identities (e.g. the pro-inflammatory potential of each individual T cell): Continuous phenotypes are by definition variable in gene expression, and separating the continuous from the discrete can sometimes be difficult.\nEnvironmental stimuli: The local environment of the cell can influence the gene expression depending on spatial position, signaling molecules, etc.\nTemporal changes: Fundamental fluxuating cellular processes, such as cell cycle, can affect the gene expression profiles of individual cells.\n\n\nImage credit: Wagner, A, et al. Revealing the vectors of cellular identity with single-cell genomics, Nat Biotechnol. 2016 (doi:https://dx.doi.org/10.1038%2Fnbt.3711)\n\n\n\nTechnical sources of variation can result in gene expression between cells being more similar/different based on technical sources instead of biological cell types/states, which can obscure the cell type identities. Technical sources of variation include:\n\nCell-specific capture efficiency: Different cells will have differing numbers of transcripts captured resulting in differences in sequencing depth (e.g. 10-50% of transcriptome).\nLibrary quality: Degraded RNA, low viability/dying cells, lots of free floating RNA, poorly dissociated cells, and inaccurate quantitation of cells can result in low quality metrics\nAmplification bias: During the amplification step of library preparation, not all transcripts are amplified to the same level.\nBatch effects: Batch effects are a significant issue for scRNA-Seq analyses, since you can see significant differences in expression due solely to the batch effect.\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nTo explore the issues generated by poor batch study design, they are highlighted nicely in this paper.\nHow to know whether you have batches?\n\nWere all RNA isolations performed on the same day?\nWere all library preparations performed on the same day?\nDid the same person perform the RNA isolation/library preparation for all samples?\nDid you use the same reagents for all samples?\nDid you perform the RNA isolation/library preparation in the same location?\n\nIf any of the answers is ‘No’, then you have batches.\nBest practices regarding batches:\n\nDesign the experiment in a way to avoid batches, if possible.\nIf unable to avoid batches:\n\nDo NOT confound your experiment by batch:\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO split replicates of the different sample groups across batches. The more replicates the better (definitely more than 2), if doing DE across conditions or making conclusions at the population level. If using inDrops, which prepares a single library at a time, alternate the sample groups (e.g. don’t prepare all control libraries first, then prepare all treatment libraries).\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO include batch information in your experimental metadata. During the analysis, we can regress out variation due to batch or integrate across batches, so it doesn’t affect our results if we have that information.",
    "crumbs": [
      "Pre-reading:",
      "Introduction to single-cell RNA-seq"
    ]
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html#conclusions",
    "href": "lessons/01_intro_to_scRNA-seq.html#conclusions",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "While scRNA-seq is a powerful and insightful method for the analysis of gene expression with single-cell resolution, there are many challenges and sources of variation that can make the analysis of the data complex or limited. Throughout the analysis of scRNA-seq data, we will try to account for or regress out variation due to the various sources of uninteresting variation in our data.\nOverall, we recommend the following:\n\nDo not perform single-cell RNA-seq unless it is necessary for the experimental question of interest. Could you answer the question using bulk sequencing, which is simpler and less costly? Perhaps FACS sorting the samples could allow for bulk analysis?\nUnderstand the details of the experimental question you wish to address. The recommended library preparation method and analysis workflow can vary based on the specific experiment.\nAvoid technical sources of variability, if possible:\n\nDiscuss experimental design with experts prior to the initiation of the experiment\nIsolate RNA from samples at same time\nPrepare libraries at same time or alternate sample groups to avoid batch confounding\nDo not confound sample groups by sex, age, or batch\n\n\n\n\n\n\n\n\n\nHow does single-nucleus RNA-seq (snRNA-seq) compare to single-cell RNA-seq?\n\n\n\nWe will not be covering snRNA-seq in this workshop! Below is a brief overview of snRNA-seq.\nsnRNA-seq analyzes the expression profiles from nuclei, instead of intact cells. As you may expect, fewer transcripts are detected from the nuclei (~7,000 genes), compared to intact cells (~11,000 genes). In some situations (depending on your research materials and goals), snRNA-seq can be the preferred method as opposed to scRNA-seq.\nSome advantages of snRNA-seq include:\n\nWorks well with hard-to-isolate samples (for example, adipocytes), as well as frozen tissues\nReduces transcriptional artifacts from the isolation process\nProvides less biased cellular coverage",
    "crumbs": [
      "Pre-reading:",
      "Introduction to single-cell RNA-seq"
    ]
  }
]